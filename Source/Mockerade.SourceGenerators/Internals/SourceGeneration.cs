using Microsoft.CodeAnalysis;

namespace Mockerade.SourceGenerators.Internals;

internal static partial class SourceGeneration
{
	public const string Header =
		"""
		//----------------------
		// <auto-generated>
		//     This code was generated by the 'Mockerade' source generator.
		//
		//     Changes to this file may cause incorrect behavior and
		//     will be lost if the code is regenerated!
		// </auto-generated>
		//----------------------

		""";

	public static string Mock() =>
		$$"""
		{{Header}}
		using System;

		namespace Mockerade;

		#nullable enable
		/// <summary>
		///     Create new mocks by calling <see cref="Mock.For{T}" />.
		/// </summary>
		public static partial class Mock
		{
			/// <summary>
			///     Create a new mock for <typeparamref name="T" /> with the default <see cref="MockBehavior" />.
			/// </summary>
			/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
			/// <remarks>
			///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			/// </remarks>
			public static Mock<T> For<T>(BaseClass.ConstructorParameters? constructorParameters = null)
			{
				var generator = new MockGenerator();
				return generator.Get<T>(constructorParameters, MockBehavior.Default)
					?? throw new NotSupportedException("Could not generate Mock<T>. Did the source generator run correctly?");
			}
			
			/// <summary>
			///     Create a new mock for <typeparamref name="T" /> with the given <paramref name="mockBehavior" />.
			/// </summary>
			/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
			/// <remarks>
			///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			///     <para />
			///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref="MockBehavior" />.
			/// </remarks>
			public static Mock<T> For<T>(MockBehavior mockBehavior)
			{
				var generator = new MockGenerator();
				return generator.Get<T>(null, mockBehavior)
					?? throw new NotSupportedException("Could not generate Mock<T>. Did the source generator run correctly?");
			}
			
			/// <summary>
			///     Create a new mock for <typeparamref name="T" /> with the given <paramref name="mockBehavior" />.
			/// </summary>
			/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
			/// <remarks>
			///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			///     <para />
			///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref="MockBehavior" />.
			/// </remarks>
			public static Mock<T> For<T>(BaseClass.ConstructorParameters constructorParameters, MockBehavior mockBehavior)
			{
				var generator = new MockGenerator();
				return generator.Get<T>(constructorParameters, mockBehavior)
					?? throw new NotSupportedException("Could not generate Mock<T>. Did the source generator run correctly?");
			}
		
			/// <summary>
			///     Create a new mock for <typeparamref name="T" /> that also implements interface <typeparamref name="T2" /> with the default <see cref="MockBehavior" />.
			/// </summary>
			/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
			/// <typeparam name="T2">Additional interface that is implemented by the mock.</typeparam>
			/// <remarks>
			///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			/// </remarks>
			public static Mock<T, T2> For<T, T2>()
			{
				var generator = new MockGenerator();
				return generator.Get<T, T2>(null, MockBehavior.Default)
					?? throw new NotSupportedException("Could not generate Mock<T>. Did the source generator run correctly?");
			}
			
			/// <summary>
			///     Create a new mock for <typeparamref name="T" /> that also implements interface <typeparamref name="T2" /> with the given <paramref name="mockBehavior" />.
			/// </summary>
			/// <typeparam name="T">Type to mock, which can be an interface or a class.</typeparam>
			/// <typeparam name="T2">Additional interface that is implemented by the mock.</typeparam>
			/// <remarks>
			///     Any interface type can be used for mocking, but for classes, only abstract and virtual members can be mocked.
			///     <para />
			///     The behavior of the mock with regards to the setups and the actual calls is determined by the <see cref="MockBehavior" />.
			/// </remarks>
			public static Mock<T, T2> For<T, T2>(MockBehavior mockBehavior)
			{
				var generator = new MockGenerator();
				return generator.Get<T, T2>(null, mockBehavior)
					?? throw new NotSupportedException("Could not generate Mock<T>. Did the source generator run correctly?");
			}
			
			private partial class MockGenerator
			{
				private object? _value;
				partial void Generate(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior, params Type[] types);
				public Mock<T>? Get<T>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior)
				{
					Generate(constructorParameters, mockBehavior, typeof(T));
					return _value as Mock<T>;
				}
				public Mock<T, T2>? Get<T, T2>(BaseClass.ConstructorParameters? constructorParameters, MockBehavior mockBehavior)
				{
					Generate(constructorParameters, mockBehavior, typeof(T), typeof(T2));
					return _value as Mock<T, T2>;
				}
			}
		}
		#nullable disable
		""";

	internal static string ToVisibilityString(this Accessibility accessibility)
		=> accessibility switch
		{
			Accessibility.Private => "private",
			Accessibility.Protected => "protected",
			Accessibility.Internal => "internal",
			Accessibility.ProtectedOrInternal => "protected internal",
			Accessibility.Public => "public",
			Accessibility.ProtectedAndInternal => "protected internal",
			_ => throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null)
		};



	internal static string GetString(this RefKind refKind)
		=> refKind switch
		{
			RefKind.None => "",
			RefKind.In => "in ",
			RefKind.Out => "out ",
			RefKind.Ref => "ref ",
			RefKind.RefReadOnlyParameter => "ref readonly ",
			_ => ""
		};
}
